package com.neusoft.oddc.multimedia.gles;import android.annotation.TargetApi;import android.graphics.Bitmap;import android.graphics.Matrix;import android.opengl.EGL14;import android.opengl.EGLSurface;import android.opengl.GLES20;import android.os.Build;import android.util.Log;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.ByteOrder;/** * Common base class for EGL surfaces. * <p/> * There can be multiple surfaces associated with a single context. */@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)public class EglSurfaceBase {    protected static final String TAG = EglSurfaceBase.class.getSimpleName();    // EglBase object we're associated with.  It may be associated with multiple surfaces.    protected EglCore eglCore;    private EGLSurface eglSurface = EGL14.EGL_NO_SURFACE;    private int frameWidth = -1;    private int frameHeight = -1;    protected EglSurfaceBase(EglCore eglBase) {        eglCore = eglBase;    }    /**     * Creates a window surface.     *     * @param surface May be a Surface or SurfaceTexture.     */    public void createWindowSurface(Object surface) {        if (eglSurface != EGL14.EGL_NO_SURFACE) {            throw new IllegalStateException("surface already created");        }        eglSurface = eglCore.createWindowSurface(surface);        frameWidth = eglCore.querySurface(eglSurface, EGL14.EGL_WIDTH);        frameHeight = eglCore.querySurface(eglSurface, EGL14.EGL_HEIGHT);    }    /**     * Creates an off-screen surface.     */    public void createOffscreenSurface(int width, int height) {        if (eglSurface != EGL14.EGL_NO_SURFACE) {            throw new IllegalStateException("surface already created");        }        eglSurface = eglCore.createOffscreenSurface(width, height);        frameWidth = width;        frameHeight = height;    }    /**     * Returns the surface's width, in pixels.     */    public int getWidth() {        return frameWidth;    }    /**     * Returns the surface's height, in pixels.     */    public int getHeight() {        return frameHeight;    }    /**     * Release the EGL surface.     */    public void releaseEglSurface() {        eglCore.releaseSurface(eglSurface);        eglSurface = EGL14.EGL_NO_SURFACE;        frameWidth = frameHeight = -1;    }    /**     * Makes our EGL context and surface current.     */    public void makeCurrent() {        eglCore.makeCurrent(eglSurface);    }    /**     * Makes our EGL context and surface current for drawing, using the supplied surface     * for reading.     */    public void makeCurrentReadFrom(EglSurfaceBase readSurface) {        eglCore.makeCurrent(eglSurface, readSurface.eglSurface);    }    /**     * Calls eglSwapBuffers.  Use this to "publish" the current frame.     *     * @return false on failure     */    public boolean swapBuffers() {        boolean result = eglCore.swapBuffers(eglSurface);        if (!result) {            Log.d(TAG, "WARNING: swapBuffers() failed");        }        return result;    }    /**     * Sends the presentation time stamp to EGL.     *     * @param nsecs Timestamp, in nanoseconds.     */    public void setPresentationTime(long nsecs) {        eglCore.setPresentationTime(eglSurface, nsecs);    }    /**     * Saves the EGL surface to a file.     * <p/>     * Expects that this object's EGL surface is current.     */    public void saveFrame(File file, final int scaleFactor) throws IOException {        if (!eglCore.isCurrent(eglSurface)) {            throw new RuntimeException("Expected EGL context/surface is not current");        }        final long startTime = System.currentTimeMillis();        final String filename = file.toString();        final ByteBuffer buffer = ByteBuffer.allocateDirect(frameWidth * frameHeight * 4);        buffer.order(ByteOrder.LITTLE_ENDIAN);        GLES20.glReadPixels(0, 0, frameWidth, frameHeight, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, buffer);        buffer.rewind();        new Thread(new Runnable() {            @Override            public void run() {                BufferedOutputStream bos = null;                try {                    bos = new BufferedOutputStream(new FileOutputStream(filename));                    Bitmap fullBitmap = Bitmap.createBitmap(frameWidth, frameHeight, Bitmap.Config.ARGB_8888);                    fullBitmap.copyPixelsFromBuffer(buffer);                    Matrix m = new Matrix();                    m.preScale(1, -1);                    if (scaleFactor != 1) {                        Bitmap scaledBitmap = Bitmap.createScaledBitmap(fullBitmap, frameWidth                                / scaleFactor, frameHeight                                / scaleFactor, true);                        Bitmap flippedScaledBitmap = Bitmap.createBitmap(scaledBitmap, 0, 0, scaledBitmap.getWidth(), scaledBitmap.getHeight(), m, true);                        flippedScaledBitmap.compress(Bitmap.CompressFormat.JPEG, 90, bos);                        scaledBitmap.recycle();                        flippedScaledBitmap.recycle();                    } else {                        Bitmap flippedBitmap = Bitmap.createBitmap(fullBitmap, 0, 0, frameWidth, frameHeight, m, true);                        flippedBitmap.compress(Bitmap.CompressFormat.JPEG, 90, bos);                        flippedBitmap.recycle();                    }                    fullBitmap.recycle();                } catch (FileNotFoundException e) {                    Log.e(TAG, "Catch FileNotFoundException when saving frame!");                } finally {                    if (bos != null)                        try {                            bos.close();                        } catch (IOException e) {                            Log.e(TAG, "Close BufferedOutputStream error!");                        }                }            }        }).start();    }    public Bitmap grabFrame(final int scaleFactor) {        if (!eglCore.isCurrent(eglSurface)) {            throw new RuntimeException("Expected EGL context/surface is not current");        }        final long startTime = System.currentTimeMillis();        final ByteBuffer buffer = ByteBuffer.allocateDirect(frameWidth * frameHeight * 4);        buffer.order(ByteOrder.LITTLE_ENDIAN);        GLES20.glReadPixels(0, 0, frameWidth, frameHeight, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, buffer);        buffer.rewind();        Bitmap fullBitmap = Bitmap.createBitmap(frameWidth, frameHeight, Bitmap.Config.ARGB_8888);        fullBitmap.copyPixelsFromBuffer(buffer);        Matrix m = new Matrix();        m.preScale(1, -1);        Bitmap result = null;        if (scaleFactor != 1) {            Bitmap scaledBitmap = Bitmap.createScaledBitmap(fullBitmap, frameWidth                    / scaleFactor, frameHeight                    / scaleFactor, true);            Bitmap flippedScaledBitmap = Bitmap.createBitmap(scaledBitmap, 0, 0, scaledBitmap.getWidth(), scaledBitmap.getHeight(), m, true);            scaledBitmap.recycle();            result = flippedScaledBitmap;        } else {            Bitmap flippedBitmap = Bitmap.createBitmap(fullBitmap, 0, 0, frameWidth, frameHeight, m, true);            result = flippedBitmap;        }        fullBitmap.recycle();        return result;    }}